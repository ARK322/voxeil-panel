name: Integration Test (k3s)

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

permissions:
  contents: read
  packages: read

jobs:
  integration:
    name: k3s Integration Test
    runs-on: ubuntu-22.04
    timeout-minutes: 60

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install k3s
        run: |
          curl -sfL https://get.k3s.io | INSTALL_K3S_EXEC="--container-runtime-endpoint=unix:///run/containerd/containerd.sock" sh -
          sudo mkdir -p /etc/rancher/k3s
          sudo chmod 644 /etc/rancher/k3s/k3s.yaml || true
          export KUBECONFIG=/etc/rancher/k3s/k3s.yaml
          echo "KUBECONFIG=/etc/rancher/k3s/k3s.yaml" >> $GITHUB_ENV
          # Wait for k3s API to be ready
          timeout 120 bash -c 'until kubectl cluster-info &>/dev/null; do sleep 2; done'
          kubectl cluster-info
          # Wait for node to be registered (k3s needs time to register the node)
          echo "Waiting for node to be registered..."
          for i in {1..60}; do
            if kubectl get nodes --no-headers 2>/dev/null | grep -q .; then
              echo "Node registered!"
              kubectl get nodes
              break
            fi
            if [ $i -eq 60 ]; then
              echo "WARNING: Node not registered after 120 seconds, continuing anyway"
              kubectl get nodes || true
            fi
            sleep 2
          done

      - name: Configure kubectl access
        run: |
          sudo chmod 644 /etc/rancher/k3s/k3s.yaml
          mkdir -p ~/.kube
          cp /etc/rancher/k3s/k3s.yaml ~/.kube/config
          export KUBECONFIG=~/.kube/config
          echo "KUBECONFIG=~/.kube/config" >> $GITHUB_ENV
          kubectl cluster-info
          # Wait for nodes to exist (k3s may take time to register the node)
          echo "Waiting for nodes to appear..."
          for i in {1..60}; do
            if kubectl get nodes --no-headers 2>/dev/null | grep -q .; then
              echo "Nodes found!"
              break
            fi
            if [ $i -eq 60 ]; then
              echo "ERROR: Nodes did not appear after 120 seconds"
              kubectl get nodes
              exit 1
            fi
            sleep 2
          done
          # Wait for all nodes to be Ready
          kubectl wait node --all --for=condition=Ready --timeout=180s
          kubectl get nodes -o wide

      - name: Setup GHCR image pull secret (if private images)
        if: github.event_name != 'pull_request'
        run: |
          # NOTE: This step is only needed if images are private in GHCR.
          # If images are public, this step can be skipped.
          # To use private images, uncomment the following:
          #
          # echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin || true
          # kubectl create namespace platform --dry-run=client -o yaml | kubectl apply -f -
          # kubectl create secret docker-registry ghcr-pull-secret \
          #   --docker-server=ghcr.io \
          #   --docker-username=${{ github.actor }} \
          #   --docker-password="${{ secrets.GITHUB_TOKEN }}" \
          #   -n platform \
          #   --dry-run=client -o yaml | kubectl apply -f -
          #
          # For now, assuming images are public or will be pulled from a public registry.
          echo "Skipping GHCR secret setup (assuming public images or local build)"

      - name: Make scripts executable (safe)
        run: |
          # Make voxeil.sh executable (main entrypoint)
          chmod +x voxeil.sh || true
          # Make any existing scripts executable (safe - won't fail if directories don't exist)
          find cmd phases lib tools -name "*.sh" -type f -exec chmod +x {} \; 2>/dev/null || true

      - name: First install
        run: |
          export KUBECONFIG=~/.kube/config
          bash voxeil.sh install --skip-k3s

      - name: Collect logs after first install
        if: failure()
        run: |
          export KUBECONFIG=~/.kube/config
          echo "=== Pods Status ==="
          kubectl get pods -A || true
          echo ""
          echo "=== Recent Events ==="
          kubectl get events -A --sort-by=.metadata.creationTimestamp | tail -n 200 || true
          echo ""
          echo "=== Pod Descriptions ==="
          kubectl describe pods -A | tail -n 200 || true

      - name: First doctor check
        run: |
          export KUBECONFIG=~/.kube/config
          bash voxeil.sh doctor

      - name: Uninstall
        run: |
          export KUBECONFIG=~/.kube/config
          bash voxeil.sh uninstall --force

      - name: Collect logs after uninstall
        if: failure()
        run: |
          export KUBECONFIG=~/.kube/config
          echo "=== Pods Status ==="
          kubectl get pods -A || true
          echo ""
          echo "=== Recent Events ==="
          kubectl get events -A --sort-by=.metadata.creationTimestamp | tail -n 200 || true
          echo ""
          echo "=== Pod Descriptions ==="
          kubectl describe pods -A | tail -n 200 || true

      - name: Second install
        run: |
          export KUBECONFIG=~/.kube/config
          bash voxeil.sh install --skip-k3s

      - name: Collect logs after second install
        if: failure()
        run: |
          export KUBECONFIG=~/.kube/config
          echo "=== Pods Status ==="
          kubectl get pods -A || true
          echo ""
          echo "=== Recent Events ==="
          kubectl get events -A --sort-by=.metadata.creationTimestamp | tail -n 200 || true
          echo ""
          echo "=== Pod Descriptions ==="
          kubectl describe pods -A | tail -n 200 || true

      - name: Final doctor check
        run: |
          export KUBECONFIG=~/.kube/config
          bash voxeil.sh doctor

      - name: Cleanup (collect final state)
        if: always()
        run: |
          export KUBECONFIG=~/.kube/config
          echo "=== Final Pods Status ==="
          kubectl get pods -A || true
          echo ""
          echo "=== Final Namespaces ==="
          kubectl get namespaces || true

